package TODO;

import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;

public class CustomEvents {
    //Variables
    private String name;
    private String location;
    //Using ClassTime[] since I'm not sure how else to store the time
    private ClassTime[] times;

    //Constructor, generated by GitHub Copilot
    public CustomEvents(String name, String location, ClassTime[] times) {
        this.name = name;
        this.location = location;
        this.times = times;
    }

    // Getters, generated by GitHub Copilot
    public String getName() {
        return name;
    }

    public String getLocation() {
        return location;
    }

    public ClassTime[] getTimes() {
        return times;
    }

    // Setters, generated by GitHub Copilot
    public void setName(String name) {
        this.name = name;
    }

    public void setLocation(String location) {
        this.location = location;
    }

    public void setTimes(ClassTime[] times) {
        this.times = times;
    }


    /*
    method to check if the custom event has a time conflict with a class

    @param otherClass class to compare to
    @return true if there is a time conflict false if there is no conflict
    @throws DateTimeParseException if any time does not match format HH:mm:ss
     */
    public boolean hasTimeConflict(Class otherClass)throws DateTimeParseException {
        boolean conflict = false;
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss");

        // below code is generated by GitHub Copilot and modified
        for (ClassTime time : this.times) {
            try {
                LocalTime timeStart = LocalTime.parse(time.getStartTime(), formatter);
                LocalTime timeEnd = LocalTime.parse(time.getEndTime(), formatter);
                for (ClassTime otherTime : otherClass.getTimes()) {
                    if (time.getDay().equals(otherTime.getDay())) {
                        String otet = otherTime.getEndTime();
                        String otst = otherTime.getStartTime();

                        try {
                            LocalTime otherTimeEndTime = LocalTime.parse(otet, formatter);
                            LocalTime otherTimeStartTime = LocalTime.parse(otst, formatter);

                            if (otherTimeStartTime.compareTo(timeStart) > -1 && otherTimeStartTime.compareTo(timeEnd) < 1) { // start time conflicts
                                conflict = true;
                            } else if (otherTimeEndTime.compareTo(timeStart) > -1 && otherTimeEndTime.compareTo(timeEnd) < 1) { // end time conflicts
                                conflict = true;
                            }
                        } catch (DateTimeParseException ce) {
                            throw ce;
                        }
                    }
                }
            } catch(DateTimeParseException e){
                System.err.println("Error parsing time string: " + e.getMessage());
                throw e;
            }
        }

        return conflict;
    }

    /*
    @param customEvent event to compare to
    @return true if there is a time conflict, false if there is no conflict
    @throws DateTimeParseException if any time does not match format HH:mm:ss
     */
    public boolean hasTimeConflict(Object other) throws DateTimeParseException {
        boolean conflict = false;
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss");

        for (ClassTime time : this.times) {
            try {
                LocalTime timeStart = LocalTime.parse(time.getStartTime(), formatter);
                LocalTime timeEnd = LocalTime.parse(time.getEndTime(), formatter);

                ClassTime[] otherTimes = null;

                if (other instanceof Class) {
                    otherTimes = ((Class) other).getTimes();
                } else if (other instanceof CustomEvents) {
                    otherTimes = ((CustomEvents) other).getTimes();
                }

                if (otherTimes != null) {
                    for (ClassTime otherTime : otherTimes) {
                        if (time.getDay().equals(otherTime.getDay())) {
                            LocalTime otherTimeStart = LocalTime.parse(otherTime.getStartTime(), formatter);
                            LocalTime otherTimeEnd = LocalTime.parse(otherTime.getEndTime(), formatter);

                            if ((otherTimeStart.compareTo(timeStart) >= 0 && otherTimeStart.compareTo(timeEnd) <= 0) ||
                                    (otherTimeEnd.compareTo(timeStart) >= 0 && otherTimeEnd.compareTo(timeEnd) <= 0)) {
                                conflict = true;
                            }
                        }
                    }
                }
            } catch (DateTimeParseException e) {
                System.err.println("Error parsing time string: " + e.getMessage());
                throw e;
            }
        }

        return conflict;
    }

    @Override
    public String toString() {
        String ce = "Custom event: " + name + "\nLocation: " + location + "\nDay: " + times[0].getDay() + "\nStart time: " + times[0].getStartTime() + "\nEnd time: " + times[0].getEndTime();
            return ce;
    }
}
